#include "sort.h"


/*
函数名：BubbleSort
作用：最简单最基本的冒泡排序算法
*/
void bubble_sort(int array[], int length)
{
	int i, j;
	for (i = 0; i < length -1; ++i)//如果i是从0开始，则每次进行完之后都要递增，如果是从length-1开始，则以后都要递减。
	{
		for (j = 0; j < length -i-1; ++j)
		{
			if (array[j] > array[j+1])//实现交换，也就是冒泡,如果是升序，则这里是大于号
			{
				swap(&array[j], &array[j+1]);
			}
		}
	}
}



/*
课后思考：
1、时间复杂度和空间复杂度分别是多少？而且时间复杂度还分最佳情况和最差情况。（但通常的时间复杂度是指最差的情况）
2、如何提高算法效率？（从时间上或空间上）
3、用其他语言如何实现？
4、如何测试？
5、如何计算算法的运行耗时？（有一种方法就像叶博之前说的，在一个算法外面套上循环，
用秒表计算这个循环的总时间，然后除以循环的次数。
或者用一些库函数，计算运行前的系统时间和运算之后的系统时间，然后相减。
（比如：C库函数clock();需要的头文件为time.h
windows系统的函数GetTickCount，需要的头文件为Winbase.h.，windows.h，库文件为Coredll.lib.）
参考
https://blog.csdn.net/Dilly__dally/article/details/80211803
）
6、如何产生随机数，然后把1~1000的数打乱，放到内存里或文件中，然后用排序算法来排序？也就是如何产生一组乱序数字？
7、待排序数组的分布特点（已经是有序数列、完全随机数列、部分随机数列）对算法效率的影响。
*/



/*
函数名：bubble_sort2
说明：实际测试，这样有时反而更慢，但如果输入的数组是有序或后一部分有序则速度会快，速度取决于数组的数据分布特点。
*/
void bubble_sort2(int a[], int n)
{
	int i, j;
	int flag;                 // 进行交换的标记，1表示进行了交换，0表示没有

	for (i=0; i<n-1; ++i)
	{
		flag = 0;
		for (j=0; j<n-1; ++j)
		{
			if (a[j] > a[j+1])
			{
				swap(&a[j], &a[j + 1]);
				flag = 1;
			}
		}
		if (flag == 0)	//如果等于0，则说明已经是有序数列了。
			break;	//注意这里是要跳出外面的循环，里面的循环不能跳过。因为至少要进行一次比较。
	}
}