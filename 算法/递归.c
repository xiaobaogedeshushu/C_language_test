#include <stdio.h>

#define TRUE	1
#define FALSE	0


/*
作用：判断
判断一个int型的整数是否是2的幂，即是否可以表示成2^X的形式(不可以用循环)。

2的幂：1,2,4,8,16,32
二进制：
1
10
100
1000
10000

*/
//算法一：按位余
int IsBinrayPower(int num) 
{
	return (num & (num - 1)) ? FALSE : TRUE;
}

//算法二：递归除以2
int IsBinrayPower_2(int num)
{
	int tmp = num;
	//0的时候返回FALSE
	if (tmp == 0 )
	{
		return FALSE;
	}
	else if (tmp == 1)
	{
		// 1 = 2 ^ 0，所以返回TRUE；
		return TRUE;
	}
	else
	{
		if (tmp % 2 == 0)
		{
			return IsBinrayPower_2(num / 2);
		}
		else
			return FALSE;
	}
}



/*
http://emb.hqyj.com/Column/Column224.htm

2010.1.8,TCL公司几位技术负责人和人力资源经理来到华清远见深圳中心进行了定向招聘的笔试和面试，其中有一套涉及到递归函数题目如下：

在下面这个程序片段中的划线处填上适当的表达式，使之逆序输出数组元素。

--------------------------------------------------------------------------------

void recur(int a[], int k)
{
int tmp;
if(_____)
{
recur(_____, _____);
tmp = a[0];
a[0] = a[k-1];
a[k-1] = tmp;
}
}

--------------------------------------------------------------------------------

这道题目要用递归的思想完成数组元素的逆序排列，我们先来复习一下有关递归函数一般解题思路。

一般而言，递归函数要有一个恰当的返回条件，以便到达那个条件的时候返回，不至于无穷嵌套进去，因此这个返回条件一定要在某个时候成立。

另外，递归解决问题的思路就是：如果我要完成A任务，我必须先完成B任务，而要完成B任务，我又必须完成C任务……以此类推，就像经典的汉诺塔问题一样，到后只需要解决掉简单的那个任务即可，以此返回便能达到目的。如下图：

回到这道题目来，如果给出一个数组{1，2，3，4，5，6，7，8}，又假设此时令k=6，即要让前6个元素逆序，我们可以这么分解问题：要让1，2，3，4，5，6逆序，我可以先让2，3，4，5逆序，只要它们逆序了，我只需交换1和6即可；而要解决这第二个问题，我可以先让3，4逆序，只要它们逆序了，我只需交换2和5即可，后我只需交换3和4即可。因此交换序列中的中间两个元素成为我们用递归思想解决这道题的第一步。

首先我们来确定返回条件，这个好办，只要k值大于等于2，我们才有交换的必要，否则根本不需要交换。这个应该没啥异议的，if语句里面填的应该就是k>1或者k>=2。

下面是递归调用自身的时候，究竟需要传递什么参数。前面已经分析过，我们在这道题中要一步步像剥洋葱一样地剥开这个数组，而且我们注意到程序中后三条语句是 a[0] 跟a[k-1] 在相互交换，因此这里的 a[0] 必定是原来数组不断往后移动得来的，也就是说第一个参数应该是 a+1 ，这样，每次递归调用的时候 a[0] 就会依次往后移动。

从程序中可以看出，当终从返回条件退出递归时要交换的是 a[0] 和 a[k-1] ，因此这里的k就应该是子序列的长度（也就是每一次“剥洋葱”之后的长度），显然，每“剥”一次“洋葱”序列的长度就减2（序列头和序列尾除去），所以第二个参数应该每次减2，即k-2，所以答案是：

--------------------------------------------------------------------------------

void recur(int a[], int k)
{
int tmp;
if(_k>1 )
{
recur(_a+1_, _k-2_);
tmp = a[0];
a[0] = a[k-1];
a[k-1] = tmp;
}
}

*/



/*
第3题:考查递归调用
这段代码对x和n完成什么样的功能(操作)
(a) x^n(x的n次幂)	答案是a
(b) x*n(x与n的乘积)
(c) n^x(n的x次幂)
(d) 以上均不是
*/
int foo(int x, int n)
{
	int val;
	val = 1;

	if (n>0)
	{
		if (n % 2 == 1) 
			val = val *x;
		val = val * foo(x*x, n / 2);
	}
	return val;
}


/*
函数名：Print
利用递归算法和栈的特性，翻转字符串。
但这样有风险，就是输入的数据不能太长，不能超过栈的大小。
*/
void Print(void)
{
	char a;
	scanf("%c", &a);
	if (a != '#')
		Print();
	printf("%c", a);
}




